/*!
 * Weinto JavaScript Library - wlib
 * http://www.weinto.com/
 *
 *
 * Copyright 20011, 2013 Weinto, Nicolas Bages
 * nicolas.bages@weinto.com
 *
 */

/*
    Prevent console issues on old browsers
 */

(function()
{
    var method;
    var noop = function () {};
    var methods = [
        'assert',       'clear',    'count', 'debug',   'dir',      'dirxml',   'error',
        'exception',    'group',    'groupCollapsed',   'groupEnd', 'info',     'log',
        'markTimeline', 'profile',  'profileEnd',       'table',    'time', '   timeEnd',
        'timeStamp',    'trace',    'warn'
    ];

    var length = methods.length;
    var console = (window.console = window.console || {});

    while(length--)
    {
        method = methods[length];

        if(!console[method])
        {
            console[method] = noop;
        }
    }
}());


/*
    Enhances console by giving the ability to display results or not. Enable/Disable console.
 */
var wlib = wlib || {};

(function()
{
    function Console()
    {
        var _isOn = false;

        var _isAvailable = function()
        {
            _isOn = (typeof console === 'object' && typeof console.log === 'function') ? true : false;

            this.console.log('wlib.console enabled: '+_isOn);

            return _isOn;
        };

        this.isAvailable   = function(){ _isAvailable(); };

        this.mode = function(action)
        {
            if(action === 'on'){ _isOn = true; }
            if(action === 'off'){ _isOn = false; }
        };

        this.log         = function(){  if(_isOn){ console.log(arguments);}};
        this.debug       = function(){  if(_isOn){ console.debug(arguments);}};
        this.info        = function(){  if(_isOn){ console.info(arguments);}};
        this.warn        = function(){  if(_isOn){ console.warn(arguments);}};
        this.error       = function(){  if(_isOn){ console.error(arguments);}};
        this.trace       = function(){  if(_isOn){ console.trace();}};
        this.group       = function(){  if(_isOn){ console.group(arguments);}};
        this.groupEnd    = function(){  if(_isOn){ console.groupEnd();}};
        this.dir         = function(){  if(_isOn){ console.dir(arguments);}};
        this.dirxml      = function(){  if(_isOn){ console.dirxml(arguments);}};
    }

    wlib.console = new Console();
    wlib.console.isAvailable();

})();
/*!
 * Forked from https://github.com/ScottHamper/Cookies
 */

var wlib = wlib || {};

/*!
 * Cookies.js - 0.3.1
 * Wednesday, April 24 2013 @ 2:28 AM EST
 *
 * Copyright (c) 2013, Scott Hamper
 * Licensed under the MIT license,
 * http://www.opensource.org/licenses/MIT
 */
(function (undefined) {
    'use strict';

    var Cookies = function (key, value, options) {
        return arguments.length === 1 ?
            Cookies.get(key) : Cookies.set(key, value, options);
    };

    // Allows for setter injection in unit tests
    Cookies._document = document;
    Cookies._navigator = navigator;

    Cookies.defaults = {
        path: '/'
    };

    Cookies.get = function (key) {
        if (Cookies._cachedDocumentCookie !== Cookies._document.cookie) {
            Cookies._renewCache();
        }

        return Cookies._cache[key];
    };

    Cookies.set = function (key, value, options) {
        options = Cookies._getExtendedOptions(options);
        options.expires = Cookies._getExpiresDate(value === undefined ? -1 : options.expires);

        Cookies._document.cookie = Cookies._generateCookieString(key, value, options);

        return Cookies;
    };

    Cookies.expire = function (key, options) {
        return Cookies.set(key, undefined, options);
    };

    Cookies._getExtendedOptions = function (options) {
        return {
            path: options && options.path || Cookies.defaults.path,
            domain: options && options.domain || Cookies.defaults.domain,
            expires: options && options.expires || Cookies.defaults.expires,
            secure: options && options.secure !== undefined ?  options.secure : Cookies.defaults.secure
        };
    };

    Cookies._isValidDate = function (date) {
        return Object.prototype.toString.call(date) === '[object Date]' && !isNaN(date.getTime());
    };

    Cookies._getExpiresDate = function (expires, now) {
        now = now || new Date();
        switch (typeof expires) {
            case 'number': expires = new Date(now.getTime() + expires * 1000); break;
            case 'string': expires = new Date(expires); break;
        }

        if (expires && !Cookies._isValidDate(expires)) {
            throw new Error('`expires` parameter cannot be converted to a valid Date instance');
        }

        return expires;
    };

    Cookies._generateCookieString = function (key, value, options) {
        key = encodeURIComponent(key);
        value = (value + '').replace(/[^!#$&-+\--:<-\[\]-~]/g, encodeURIComponent);
        options = options || {};

        var cookieString = key + '=' + value;
        cookieString += options.path ? ';path=' + options.path : '';
        cookieString += options.domain ? ';domain=' + options.domain : '';
        cookieString += options.expires ? ';expires=' + options.expires.toUTCString() : '';
        cookieString += options.secure ? ';secure' : '';

        return cookieString;
    };

    Cookies._getCookieObjectFromString = function (documentCookie) {
        var cookieObject = {};
        var cookiesArray = documentCookie ? documentCookie.split('; ') : [];

        for (var i = 0; i < cookiesArray.length; i++) {
            var cookieKvp = Cookies._getKeyValuePairFromCookieString(cookiesArray[i]);

            if (cookieObject[cookieKvp.key] === undefined) {
                cookieObject[cookieKvp.key] = cookieKvp.value;
            }
        }

        return cookieObject;
    };

    Cookies._getKeyValuePairFromCookieString = function (cookieString) {
        // "=" is a valid character in a cookie value according to RFC6265, so cannot `split('=')`
        var separatorIndex = cookieString.indexOf('=');

        // IE omits the "=" when the cookie value is an empty string
        separatorIndex = separatorIndex < 0 ? cookieString.length : separatorIndex;

        return {
            key: decodeURIComponent(cookieString.substr(0, separatorIndex)),
            value: decodeURIComponent(cookieString.substr(separatorIndex + 1))
        };
    };

    Cookies._renewCache = function () {
        Cookies._cache = Cookies._getCookieObjectFromString(Cookies._document.cookie);
        Cookies._cachedDocumentCookie = Cookies._document.cookie;
    };

    Cookies._areEnabled = function () {
        var testKey = 'cookies.js';
        var areEnabled = Cookies.set(testKey, 1).get(testKey) === '1';
        Cookies.expire(testKey);
        return areEnabled;
    };

    Cookies.enabled = Cookies._areEnabled();

    // AMD support
    if (typeof define === 'function' && define.amd) {
        define(function () { return Cookies; });
    // CommonJS and Node.js module support.
    } else if (typeof exports !== 'undefined') {
        // Support Node.js specific `module.exports` (which can be a function)
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = Cookies;
        }
        // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
        exports.Cookies = Cookies;
    } else {
        window.wlib.cookies = Cookies;
    }
})();
/*!
 * Weinto JavaScript Library - wlib
 * http://www.weinto.com/
 *
 *
 * Copyright 20011, 2013 Weinto, Nicolas Bages
 * nicolas.bages@weinto.com
 *
 */

/*
	Provide windows.location.origin to all browsers
 */
window.location.origin = window.location.origin || window.location.protocol+'//'+window.location.host;



if (!Array.prototype.some)
{
  Array.prototype.some = function(fun /*, thisArg */)
  {
	'use strict';

	if (this === void 0 || this === null){
	  throw new TypeError();
	}

	var t = Object(this);
	var len = t.length >>> 0;
	if (typeof fun !== 'function'){
	  throw new TypeError();
	}

	var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
	for (var i = 0; i < len; i++)
	{
	  if (i in t && fun.call(thisArg, t[i], i, t)){
		return true;
	  }
	}

	return false;
  };
}

if(typeof jQuery === 'function' && typeof jQuery.fn.jquery === 'string')
{
	$(window).on('resize', function()
	{
		if(this.resizeTO)
		{
			clearTimeout(this.resizeTO);
		}

		this.resizeTO = setTimeout(function()
		{
			$(this).trigger('resizeEnd');
		}, 300);
	});
}

// Basic support	FF 4	Chrome 5	IE 9	Opera 12	Safari 5

if (!Object.keys) {
  Object.keys = (function () {
	var hasOwnProperty = Object.prototype.hasOwnProperty,
		hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
		dontEnums = [
		  'toString',
		  'toLocaleString',
		  'valueOf',
		  'hasOwnProperty',
		  'isPrototypeOf',
		  'propertyIsEnumerable',
		  'constructor'
		],
		dontEnumsLength = dontEnums.length;

	return function (obj) {
	  if (typeof obj !== 'object' && typeof obj !== 'function' || obj === null){ throw new TypeError('Object.keys called on non-object'); }

	  var result = [];

	  for (var prop in obj) {
		if (hasOwnProperty.call(obj, prop)){ result.push(prop); }
	  }

	  if (hasDontEnumBug) {
		for (var i=0; i < dontEnumsLength; i++) {
		  if (hasOwnProperty.call(obj, dontEnums[i])){result.push(dontEnums[i]); }
		}
	  }
	  return result;
	};
  })();
}






(function() {
	var lastTime = 0;
	var vendors = ['ms', 'moz', 'webkit', 'o'];
	for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
		window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
		window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
	}

	if (!window.requestAnimationFrame){
		window.requestAnimationFrame = function(callback, element) {
			var currTime = new Date().getTime();
			var timeToCall = Math.max(0, 16 - (currTime - lastTime));
			var id = window.setTimeout(function() { callback(currTime + timeToCall); }, 
			  timeToCall);
			lastTime = currTime + timeToCall;
			return id;
		};
	}

	if (!window.cancelAnimationFrame){
		window.cancelAnimationFrame = function(id) {
			clearTimeout(id);
		};
	}
}());


// requestAnimationFrame() shim by Paul Irish
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
window.requestAnimFrame = (function() {
  return  window.requestAnimationFrame       || 
	  window.webkitRequestAnimationFrame || 
	  window.mozRequestAnimationFrame    || 
	  window.oRequestAnimationFrame      || 
	  window.msRequestAnimationFrame     || 
	  function(/* function */ callback, /* DOMElement */ element){
		window.setTimeout(callback, 1000 / 60);
	  };
})();





/**
 * Behaves the same as setInterval except uses requestAnimationFrame() where possible for better performance
 * @param {function} fn The callback function
 * @param {int} delay The delay in milliseconds
 */
window.requestInterval = function(fn, delay) {
  if( !window.requestAnimationFrame       && 
	!window.webkitRequestAnimationFrame && 
	!(window.mozRequestAnimationFrame && window.mozCancelRequestAnimationFrame) && // Firefox 5 ships without cancel support
	!window.oRequestAnimationFrame      && 
	!window.msRequestAnimationFrame){
	  return window.setInterval(fn, delay);
	}

  var start = new Date().getTime(),
	handle = {};

  function loop() {
	var current = new Date().getTime(),
	  delta = current - start;

	if(delta >= delay) {
	  fn.call();
	  start = new Date().getTime();
	}

	handle.value = requestAnimFrame(loop);
  }

  handle.value = requestAnimFrame(loop);
  return handle;
};

/**
 * Behaves the same as clearInterval except uses cancelRequestAnimationFrame() where possible for better performance
 * @param {int|object} fn The callback function
 */
window.clearRequestInterval = function(handle) {
	if( ! handle ){ return; }
	window.cancelAnimationFrame ? window.cancelAnimationFrame(handle.value) :
	window.webkitCancelAnimationFrame ? window.webkitCancelAnimationFrame(handle.value) :
	window.webkitCancelRequestAnimationFrame ? window.webkitCancelRequestAnimationFrame(handle.value) : /* Support for legacy API */
	window.mozCancelRequestAnimationFrame ? window.mozCancelRequestAnimationFrame(handle.value) :
	window.oCancelRequestAnimationFrame ? window.oCancelRequestAnimationFrame(handle.value) :
	window.msCancelRequestAnimationFrame ? window.msCancelRequestAnimationFrame(handle.value) :
	clearInterval(handle);
};



/**
 * Behaves the same as setTimeout except uses requestAnimationFrame() where possible for better performance
 * @param {function} fn The callback function
 * @param {int} delay The delay in milliseconds
 */
 
window.requestTimeout = function(fn, delay) {
  if( !window.requestAnimationFrame       && 
	!window.webkitRequestAnimationFrame && 
	!(window.mozRequestAnimationFrame && window.mozCancelRequestAnimationFrame) && // Firefox 5 ships without cancel support
	!window.oRequestAnimationFrame      && 
	!window.msRequestAnimationFrame){
	  return window.setTimeout(fn, delay);
	}
	  
  var start = new Date().getTime(),
	handle = {};
	
  function loop(){
	var current = new Date().getTime(),
	  delta = current - start;

	if(delta >= delay){
		fn.call();
	}else{
		handle.value = requestAnimFrame(loop);
	}
  }
  
  handle.value = requestAnimFrame(loop);
  return handle;
};
 
/**
 * Behaves the same as clearTimeout except uses cancelRequestAnimationFrame() where possible for better performance
 * @param {int|object} fn The callback function
 */
window.clearRequestTimeout = function(handle) {
	if( ! handle ){ return; }
	window.cancelAnimationFrame ? window.cancelAnimationFrame(handle.value) :
	window.webkitCancelAnimationFrame ? window.webkitCancelAnimationFrame(handle.value) :
	window.webkitCancelRequestAnimationFrame ? window.webkitCancelRequestAnimationFrame(handle.value) : /* Support for legacy API */
	window.mozCancelRequestAnimationFrame ? window.mozCancelRequestAnimationFrame(handle.value) :
	window.oCancelRequestAnimationFrame ? window.oCancelRequestAnimationFrame(handle.value) :
	window.msCancelRequestAnimationFrame ? window.msCancelRequestAnimationFrame(handle.value) :
	clearTimeout(handle);
};


if (!Array.prototype.find) {
  Object.defineProperty(Array.prototype, 'find', {
	enumerable: false,
	configurable: true,
	writable: true,
	value: function(predicate) {
	  if (this == null) {
		throw new TypeError('Array.prototype.find called on null or undefined');
	  }
	  if (typeof predicate !== 'function') {
		throw new TypeError('predicate must be a function');
	  }
	  var list = Object(this);
	  var length = list.length >>> 0;
	  var thisArg = arguments[1];
	  var value;

	  for (var i = 0; i < length; i++) {
		if (i in list) {
		  value = list[i];
		  if (predicate.call(thisArg, value, i, list)) {
			return value;
		  }
		}
	  }
	  return undefined;
	}
  });
}

/*!
 * Weinto JavaScript Library - wlib
 * http://www.weinto.com/
 *
 *
 * Copyright 20011, 2013 Weinto, Nicolas Bages
 * nicolas.bages@weinto.com
 *
 */

/*
	Singleton based on jQuery events
 */

var wlib = wlib || {};

(function($)
{
	function Events()
	{
		this._e = $({});

		this.listen = function()
		{
			this._e.on.apply(this._e, arguments);
		};

		this.ignore = function()
		{
			this._e.off.apply(this._e, arguments);
		};

		this.trigger = function()
		{
			this._e.trigger.apply(this._e, arguments);
		};
	}

	wlib.events = new Events();

})(jQuery);
/*!
 * Weinto JavaScript Library - wlib
 * http://www.weinto.com/
 *
 *
 * Copyright 20011, 2013 Weinto, Nicolas Bages
 * nicolas.bages@weinto.com
 *
 */

var wlib = wlib || {};

wlib.form = wlib.form || {};

wlib.form.element = (function($)
{
	function Element(el)
	{
		this.el = el;
		this.val = this.el.val();
		this.errors = [];
		this.rules = [];
		this.eventObj = $({});

		this.addRule = function(rule)
		{
			this.rules.push(rule);
			return this;
		};

		this.validate = function()
		{
			var self = this;

			this.errors = [];

			this.val = self.el.val();
			
			$.each(self.rules, function(index, rule)
			{
				self.eventObj.trigger('valid');
				var is_valid = false;
				switch(rule.name)
				{
					case 'email' :
							is_valid = wlib.regex.check('email', self.val);
							if(!is_valid){self.errors.push({name:rule.name, message:rule.message});}
						break;
					case 'url' :
							is_valid = wlib.regex.check('url', self.val);
							if(!is_valid){self.errors.push({name:rule.name, message:rule.message});}
						break;
					case 'twitterusername' :
							is_valid = wlib.regex.check('twitterusername', self.val);
							if(!is_valid){self.errors.push({name:rule.name, message:rule.message});}
						break;
					case 'isNumber' :
							is_valid = wlib.regex.isNumber(self.val);
							if(!is_valid){self.errors.push({name:rule.name, message:rule.message});}
						break;
					case 'strlenMin' :
							is_valid = wlib.regex.strlenMin(self.val, rule.limit);
							if(!is_valid){self.errors.push({name:rule.name, message:rule.message});}
						break;
					case 'strlenMax' :
							is_valid = wlib.regex.strlenMax(self.val, rule.limit);
							if(!is_valid){self.errors.push({name:rule.name, message:rule.message});}
						break;
					case 'nbvalMin' :
							is_valid = wlib.regex.nbvalMin(self.val, rule.limit);
							if(!is_valid){self.errors.push({name:rule.name, message:rule.message});}
						break;
					case 'nbvalMax' :
							is_valid = wlib.regex.nbvalMax(self.val, rule.limit);
							if(!is_valid){self.errors.push({name:rule.name, message:rule.message});}
						break;
					case 'not_empty' :
							is_valid = wlib.regex.not_empty(self.val);
							if(is_valid){self.errors.push({name:rule.name, message:rule.message});}
						break;
					case 'same_as' :
							is_valid = wlib.regex.same_as(self.val, rule.challenge.val());
							if(!is_valid){self.errors.push({name:rule.name, message:rule.message});}
						break;
					case 'regex' :
							is_valid = wlib.regex.regex(self.val, rule.regex);
							if(!is_valid){self.errors.push({name:rule.name, message:rule.message});}
						break;
				}

			});

			if(self.errors.length > 0)
			{
				self.eventObj.trigger('error');
			}

			return self.errors;
		};

		this.hasError = function(key)
		{
			return ( (this.errors.join().search(key) >= 0) ? true : false);
		};

		this.on = function(key, method)
		{
			var self = this;

	        if(key === 'valid')
	        {
	            this.eventObj.on('valid', function(e, data)
	            {
	                method.call(self, data);
	            });
	        }
	        else if(key === 'error')
	        {
	            this.eventObj.on('error', function(e, data)
	            {
	            	data = data || {};
	            	data.errors = self.errors;
	                method.call(self, data);
	            });
	        }
	        else
	        {
	            this.eventObj.on('xhr-error', function(e, data)
	            {
	                method.call(self, data);
	            });
	        }
	        return this;
	    };
	}

	return Element;

})(jQuery);
var wlib = wlib || {};

(function() {
	function i18n() {

		if(! wlib.cookies)
		{
			console.error('wlib.cookes required to use i18n');
		}

		this.current    = '';
		this.allowed    = ['fr', 'es', 'en'];
		this.default 	= 'fr';
	}

	i18n.prototype.navigator = function()
	{
		var lang = window.navigator.userLanguage || window.navigator.language;
		return lang;
	};

	i18n.prototype.exists = function(lang)
	{
		return this.allowed.some(function(el, index, array){
			return el === lang;
		});
	};

	i18n.prototype.setCurrent = function(lang)
	{
		wlib.cookies.set('lang', lang);
		this.current = lang;
	};

	i18n.prototype.setLang = function(lang)
	{
		if(lang === '' || lang === null)
		{
			lang = wlib.cookies.get('lang');
			if(! lang)
			{
				lang = this.navigator();
			}
		}

		if( ! this.exists(lang))
		{
			// This lang doesn't exist so we use the default one
			lang = this.default;
		}

		this.setCurrent(lang);
		wlib.console.info('Language used:', lang);
	};

	i18n.prototype.userLang = function()
	{
		var lang = wlib.cookies.get('lang');
		if(lang){
			return lang;
		}

		lang = this.navigator();

		if( ! this.exists(lang))
		{
			lang = this.default;
		}

		return lang;
	};


	wlib.i18n = i18n;

})();
/*!
 * Weinto JavaScript Library - wlib
 * http://www.weinto.com/
 *
 *
 * Copyright 20011, 2013 Weinto, Nicolas Bages
 * nicolas.bages@weinto.com
 *
 */

var wlib = wlib || {};

wlib.player = wlib.player || {};


/*!
 * Weinto JavaScript Library - wlib
 * http://www.weinto.com/
 *
 *
 * Copyright 20011, 2013 Weinto, Nicolas Bages
 * nicolas.bages@weinto.com
 *
 */

var wlib = wlib || {};

(function()
{
	function Regex()
	{
		var _regex = {
			email : /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,})+$/,
			url : /(http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/,
			number : /[0-9]|\./,
			twitterusername : /(^|[^@\w])@(\w{1,15})\b/
		};

		this.add = function(name, regex)
		{
			_regex[name] = regex;
		};

		this.check = function(regex, value)
		{
			return _regex[regex].test(value);
		};

		this.isNumber = function(value)
		{
			return !isNaN(parseFloat(value)) && isFinite(value);
		};

		this.strlenMin = function(mixed_var, limit)
		{
			return (mixed_var.length >= limit ? true : false);
		};

		this.strlenMax = function(mixed_var, limit)
		{
			return (mixed_var.length <= limit ? true : false);
		};

		this.nbvalMin = function(nb, limit)
		{
			return (nb >= limit ? true : false);
		};

		this.nbvalMax = function(nb, limit)
		{
			return (nb <= limit ? true : false);
		};

		this.not_empty = function(mixed_var)
		{
			var undef, key, i, len;
			var emptyValues = [undef, null, false, 0, '', '0'];

			for (i = 0, len = emptyValues.length; i < len; i++)
			{
				if (mixed_var === emptyValues[i])
				{
					return true;
				}
			}

			if (typeof mixed_var === "object")
			{
				for (key in mixed_var) {
					// TODO: should we check for own properties only?
					//if (mixed_var.hasOwnProperty(key)) {
					return false;
					//}
				}
				return true;
			}
			return false;
		};

		this.same_as = function(str, challenge)
		{
			return (str === challenge ? true : false);
		};

	}

	wlib.regex = new Regex();

})();
/*!
 * Weinto JavaScript Library - wlib
 * http://www.weinto.com/
 *
 *
 * Copyright 20011, 2013 Weinto, Nicolas Bages
 * nicolas.bages@weinto.com
 *
 */

var wlib = wlib || {};

(function()
{
	function Request()
	{
		var vars = [], hash;
	    var hashes = window.location.href.slice( window.location.href.indexOf('?') + 1 ).split('&');
	    for(var i = 0; i < hashes.length; i++){
	        hash = hashes[i].split('=');
	        vars.push(hash[0]);
	        vars[hash[0]] = hash[1];
	    }

	    this.get_param = function(key)
	    {
	    	return vars[key];
	    };

	}


	wlib.request = new Request();

})();
var wlib = wlib || {};
wlib.viewport = (function()
{
	var Viewport = function()
	{
		if(! wlib.console ){console.error('wlib.console is required to use Viewport class.');}
	};

	Viewport.prototype.disableScroll = function()
	{
		var htmlElement = document.getElementsByTagName('html')[0];
		htmlElement.style.overflow = 'hidden';
	};

	Viewport.prototype.enableScroll = function()
	{
		var htmlElement = document.getElementsByTagName('html')[0];
		htmlElement.style.overflow = 'auto';
	};

	Viewport.prototype.breakpoint = (function()
	{

		var Viewport_Breakpoint = function()
		{
			var t = this;
			this.sizes = [];
			this.original = null;
		};

		Viewport_Breakpoint.prototype.set = function(name, mediaquery)
		{
			this.sizes.push({name:name, mq:mediaquery});
			this.original = this.identify();
			return this;
		};

		Viewport_Breakpoint.prototype.get = function(name)
		{
			var index = this.sizes.find(function(element, index, value)
			{
				if(element.name === name)
				{
					return index;
				}
			});

			return index;
		};

		Viewport_Breakpoint.prototype.identify = function()
		{
			var element = this.sizes.find(function(element, index, value)
			{
				if(window.matchMedia && matchMedia(element.mq).matches)
				{
					return element;
				}
			});

			if(typeof element !== 'undefined')
			{
				return element.name;
			}

			return false;
		};

		return new Viewport_Breakpoint();

	})();


	Viewport.prototype.orientation = (function()
	{
		function Viewport_Orientation(){
			var t = this;

			if(typeof window.orientationchange === 'undefined')
			{
				window.orientationchange = new CustomEvent("orientationchange", { "type": "orientationchange" });
				wlib.console.warn('Viewport: Event "orientationchange" was previously not supported on this device. Now added.');
			}

			window.addEventListener('orientationchange', function(e)
			{
				if(typeof t.onChange === 'function')
				{
					t.onChange.apply(t, e);
				}
				else
				{
					wlib.console.log(t.get());
				}
			}, false);
		}

		Viewport_Orientation.prototype.get = function()
		{
			if(window.matchMedia)
			{
				return matchMedia("(orientation: landscape)").matches === true ? 'landscape' : 'portrait';
			}
		};

		Viewport_Orientation.prototype.onChange = false;

		return new Viewport_Orientation();
	})();

	return Viewport;

})();

/*!
 * Weinto JavaScript Library - wlib
 * http://www.weinto.com/
 *
 *
 * Copyright 20011, 2013 Weinto, Nicolas Bages
 * nicolas.bages@weinto.com
 *
 */

var wlib = wlib || {};

wlib.xmljson = wlib.xmljson || {};


wlib.xmljson.xml2json = function(xml)
{
	// Create the return object
	var obj = {};

	if (xml.nodeType === 1)  // element
	{
		// do attributes
		if (xml.attributes.length > 0)
		{
			obj["@attributes"] = {};
			for (var j = 0; j < xml.attributes.length; j++)
			{
				var attribute  = xml.attributes.item(j);
				obj["@attributes"][attribute.nodeName] = attribute.nodeValue;
			}
		}
	}
	else if(xml.nodeType === 3) // text
	{
		obj = xml.nodeValue;
	}

	// do children
	if (xml.hasChildNodes())
	{
		for(var i = 0; i < xml.childNodes.length; i++)
		{
			var item     = xml.childNodes.item(i);
			var nodeName = item.nodeName;
			if (typeof(obj[nodeName]) === "undefined")
			{
				obj[nodeName] = xmlToJson(item);
			}
			else
			{
				if (typeof(obj[nodeName].push) === "undefined")
				{
					var old       = obj[nodeName];
					obj[nodeName] = [];
					obj[nodeName].push(old);
				}
				obj[nodeName].push(xmlToJson(item));
			}
		}
	}
	return obj;
};
